package org.firstinspires.ftc.teamcode.Logic.Vision;

import android.util.Log;

import org.corningrobotics.enderbots.endercv.OpenCVPipeline;
import org.firstinspires.ftc.teamcode.Logic.Vision.Positions;
import org.firstinspires.ftc.teamcode.Utilities.json.SafeJsonReader;
import org.opencv.core.Mat;
import org.opencv.core.Point;
import org.opencv.core.Scalar;
import org.opencv.core.Size;
import org.opencv.core.Core;
import org.opencv.imgproc.Imgproc;

public class MyGoldDetector extends OpenCVPipeline {
    static final String TAG = "ftc9773_goldDetector";
    Mat blurred ;
    Mat unblurred ;
    Mat filtered ;
    Boolean leftIsGold = null,
            rightIsGold = null;
    int totalWidth, totalHeight;

    // needs to be tunable
    double [] relBoxOne = {.1818, 0.4718137255, .3880, 0.6050857843};
    double [] relBoxTwo = {0.7761437908, 0.5208333333, 0.9803921569, 0.6740196078 };

    // actual box bounds:
    int[] boxOneBounds, boxTwoBounds;

    double minDetectionThreshold;
    double onVal = 120.0;
    double leftCorrectPercent, rightCorrectPercent;
    final static Scalar blue = new Scalar(0,0,255);
    final static Scalar red = new Scalar(255, 0,0);

    boolean returnMat;




     Positions position = Positions.UNKNOWN;
     public MyGoldDetector(){
         super();
         SafeJsonReader reader = new SafeJsonReader("VisionThresholds");
         minDetectionThreshold = reader.getDouble("minDetectionThreshold", 0.1);
         // get boxOne Pos
         relBoxOne[0] = reader.getDouble("BoxOneTopRightX",.1818);
         relBoxOne[1] = reader.getDouble("BoxOneTopRightY",0.4718137255);
         relBoxOne[2] = reader.getDouble("BoxOneBottomLeftX",.3880);
         relBoxOne[3] = reader.getDouble("BoxOneBottomLeftY",0.6050857843);
         // get boxTwo Pos
         relBoxTwo[0] = reader.getDouble("BoxTwoTopRightX",0.7761437908);
         relBoxTwo[1] = reader.getDouble("BoxTwoTopRightY",0.5208333333);
         relBoxTwo[2] = reader.getDouble("BoxTwoBottomLeftX",0.9803921569);
         relBoxTwo[3] = reader.getDouble("BoxTwoBottomLeftY",0.6740196078);

         returnMat = reader.getBoolean("returnMat", false);


     }

    
    @Override
    public Mat processFrame(Mat rgba, Mat gray) {
        // clear mats from past runs
        blurred = new Mat();
        unblurred = new Mat();
        filtered = new Mat();
        // convert from RGB color space to hsv color space
        Imgproc.cvtColor(rgba, unblurred,Imgproc.COLOR_RGB2HSV);
        Imgproc.blur(unblurred,blurred, new Size(40,40));
        Core.inRange(blurred,new Scalar(8,158,124),new Scalar(65,255,255), filtered);

        findGold(filtered);

        // provide feedback using the boolean values generated by the findGold() method
        Scalar leftColor, rightColor;
        if(leftIsGold) leftColor =  blue; else leftColor = red;
        if(rightIsGold) rightColor= blue; else rightColor= red;
        // draw left and right boxes with the corresponding colors;
        Imgproc.rectangle(rgba,new Point(boxOneBounds[0],boxOneBounds[1]),new Point(boxOneBounds[2],boxOneBounds[3]),leftColor,8);
        Imgproc.rectangle(rgba,new Point(boxTwoBounds[0],boxTwoBounds[1]),new Point(boxTwoBounds[2],boxTwoBounds[3]),rightColor,8);
        if(returnMat) return rgba;
        else return null;
    }

    // looks at processed frame, to get location of gold
    public void findGold(Mat input){
        totalWidth = input.width();
        totalHeight = input.height();
        // find the actual size of the bounding box.
        boxOneBounds = scaleArray(relBoxOne, totalWidth,totalHeight);
        boxTwoBounds = scaleArray(relBoxTwo, totalWidth, totalHeight);
        // first look in box 1.
        // iterate throughout the box
        int correctCounter =0; int counter =0;
        for (int x = boxOneBounds[0];x < boxOneBounds[2]; x++){
            for (int y = boxOneBounds[1]; y < boxOneBounds[3];y++ ){
                counter ++;
                //TODO: index value a complete guess. I might have to test a couple values
                if(input.get(y,x)[0] > onVal){
                    // if it is correct, increment the correctVals Counter
                    correctCounter ++;
                }
            }
        }
        leftCorrectPercent = ((double)correctCounter) / ((double)(counter));
        Log.i(TAG, "leftSelection: got " +correctCounter +" hits out of " + counter + " fraction: " + leftCorrectPercent);

        // reset counters
        correctCounter = counter = 0 ;
        // then look in box 2
        for (int x = boxTwoBounds[0];x < boxTwoBounds[2]; x++){
            for (int y = boxTwoBounds[1]; y < boxTwoBounds[3];y++ ) {
                counter++;
                //TODO: index value a complete guess. I might have to test a couple values
                if (input.get(y, x)[0] > onVal) {
                    // if it is correct, increment the correctVals Counter
                    correctCounter++;
                }
            }
        }
        rightCorrectPercent = ((double)correctCounter) / ((double)(counter));
        Log.i(TAG, "rightSelection: got " +correctCounter +" hits out of " + counter + " fraction: " + rightCorrectPercent);

        leftIsGold = leftCorrectPercent > minDetectionThreshold;
        rightIsGold = rightCorrectPercent > minDetectionThreshold;

        // determine the position of the gold.

        // start with the odd case, if both are true choose the position with the most yellow
        if(leftIsGold && rightIsGold){
            //choose the position with the most yellow
            if(leftCorrectPercent > rightCorrectPercent) position = Positions.TWO;
            else if(leftCorrectPercent < rightCorrectPercent) position = Positions.THREE;
        } // otherwise look at which is / isnt true
        else if (leftIsGold) position = Positions.TWO;
        else if (rightIsGold) position = Positions.ONE;
        else position = Positions.THREE;
    }

    private int[]scaleArray(double[] input, int scalarX, int scalarY){
        int[] result = new int[input.length];
        for(int i = 0; i< input.length; i+=2){
            result[i] = (int)(scalarX * input[i]);
        }
        for(int i = 1; i< input.length; i+=2){
            result[i] = (int)(scalarY * input[i]);
        }
        return result;
    }

    public Positions getPosition() {
        return position;
    }
}
