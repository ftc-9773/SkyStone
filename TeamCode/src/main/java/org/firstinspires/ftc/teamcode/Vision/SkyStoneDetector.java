package org.firstinspires.ftc.teamcode.Vision;

import android.util.Log;

import org.corningrobotics.enderbots.endercv.OpenCVPipeline;
import org.firstinspires.ftc.teamcode.Utilities.json.SafeJsonReader;
import org.opencv.core.Mat;
import org.opencv.core.Point;
import org.opencv.core.Scalar;
import org.opencv.core.Size;
import org.opencv.core.Core;
import org.opencv.imgproc.Imgproc;

public class SkyStoneDetector extends OpenCVPipeline {

    static final String TAG = "ftc9773skyStoneDetector";
    Mat blurred ;
    Mat unblurred ;
    Mat filtered ;
    Boolean leftIsBlack = null, rightIsBlack = null;
    int totalWidth, totalHeight;

    // needs to be tunable
    double [] relBoxOne = {.1818, 0.4718137255, .3880, 0.6050857843};
    double [] relBoxTwo = {0.7761437908, 0.5208333333, 0.9803921569, 0.6740196078 };

    // actual box bounds:
    int[] boxOneBounds, boxTwoBounds;

    double minDetectionThreshold;
    double onVal = 120.0;
    double leftCorrectPercent, rightCorrectPercent;
    final static Scalar blue = new Scalar(0,0,255);
    final static Scalar red = new Scalar(255, 0,0);

    boolean returnMat;



    skyPositions position = skyPositions.unknown;

    public SkyStoneDetector(){
        super();
        SafeJsonReader reader = new SafeJsonReader("VisionThresholds");
        minDetectionThreshold = reader.getDouble("minDetectionThreshold", 0.1);
        // get boxOne Pos
        relBoxOne[0] = reader.getDouble("BoxOneTopRightX",.1818);
        relBoxOne[1] = reader.getDouble("BoxOneTopRightY",0.4718137255);
        relBoxOne[2] = reader.getDouble("BoxOneBottomLeftX",.3880);
        relBoxOne[3] = reader.getDouble("BoxOneBottomLeftY",0.6050857843);
        // get boxTwo Pos
        relBoxTwo[0] = reader.getDouble("BoxTwoTopRightX",0.7761437908);
        relBoxTwo[1] = reader.getDouble("BoxTwoTopRightY",0.5208333333);
        relBoxTwo[2] = reader.getDouble("BoxTwoBottomLeftX",0.9803921569);
        relBoxTwo[3] = reader.getDouble("BoxTwoBottomLeftY",0.6740196078);

        returnMat = reader.getBoolean("returnMat", false);


    }


    @Override
    public Mat processFrame(Mat rgba, Mat gray) {
        // clear mats from past runs
        blurred = new Mat();
        unblurred = new Mat();
        filtered = new Mat();
        // convert from RGB color space to hsv color space
        Imgproc.cvtColor(rgba, unblurred,Imgproc.COLOR_RGB2HSV);
        Imgproc.blur(unblurred,blurred, new Size(40,40));
        Core.inRange(blurred,new Scalar(8,158,124),new Scalar(65,255,255), filtered);

        findBlack(filtered);

        // provide feedback using the boolean values generated by the findBlack() method
        Scalar leftColor, rightColor;
        if(leftIsBlack) leftColor =  blue; else leftColor = red;
        if(rightIsBlack) rightColor = blue; else rightColor= red;
        // draw left and right boxes with the corresponding colors;
        Imgproc.rectangle(rgba,new Point(boxOneBounds[0],boxOneBounds[1]),new Point(boxOneBounds[2],boxOneBounds[3]),leftColor,8);
        Imgproc.rectangle(rgba,new Point(boxTwoBounds[0],boxTwoBounds[1]),new Point(boxTwoBounds[2],boxTwoBounds[3]),rightColor,8);
        if(returnMat) return rgba;
        else return null;
    }

    // looks at processed frame, to get location of black
    public void findBlack(Mat input){
        totalWidth = input.width();
        totalHeight = input.height();
        // find the actual size of the bounding box.
        boxOneBounds = scaleArray(relBoxOne, totalWidth,totalHeight);
        boxTwoBounds = scaleArray(relBoxTwo, totalWidth, totalHeight);
        // first look in box 1.
        // iterate throughout the box
        int correctCounter =0; int counter =0;
        for (int x = boxOneBounds[0];x < boxOneBounds[2]; x++){
            for (int y = boxOneBounds[1]; y < boxOneBounds[3];y++ ){
                counter ++;
                //TODO: index value a complete guess. I might have to test a couple values
                if(input.get(y,x)[0] > onVal){
                    // if it is correct, increment the correctVals Counter
                    correctCounter ++;
                }
            }
        }
        leftCorrectPercent = ((double)correctCounter) / ((double)(counter));
        Log.i(TAG, "leftSelection: got " +correctCounter +" hits out of " + counter + " fraction: " + leftCorrectPercent);

        // reset counters
        correctCounter = counter = 0 ;
        // then look in box 2
        for (int x = boxTwoBounds[0];x < boxTwoBounds[2]; x++){
            for (int y = boxTwoBounds[1]; y < boxTwoBounds[3];y++ ) {
                counter++;
                //TODO: index value a complete guess. I might have to test a couple values
                if (input.get(y, x)[0] > onVal) {
                    // if it is correct, increment the correctVals Counter
                    correctCounter++;
                }
            }
        }
        rightCorrectPercent = ((double)correctCounter) / ((double)(counter));
        Log.i(TAG, "rightSelection: got " +correctCounter +" hits out of " + counter + " fraction: " + rightCorrectPercent);

        leftIsBlack = leftCorrectPercent > minDetectionThreshold;
        rightIsBlack = rightCorrectPercent > minDetectionThreshold;

        // determine the position of the gold.

        // start with the odd case, if both are true choose the position with the most yellow
        if(leftIsBlack && rightIsBlack){
            //choose the position with the most yellow
            if(leftCorrectPercent > rightCorrectPercent) position = skyPositions.center;
            else if(leftCorrectPercent < rightCorrectPercent) position = skyPositions.right;
        } // otherwise look at which is / isnt true
        else if (leftIsBlack) position = skyPositions.center;
        else if (rightIsBlack) position = skyPositions.right;
        else position = skyPositions.left;
    }

    private int[]scaleArray(double[] input, int scalarX, int scalarY){
        int[] result = new int[input.length];
        for(int i = 0; i< input.length; i+=2){
            result[i] = (int)(scalarX * input[i]);
        }
        for(int i = 1; i< input.length; i+=2){
            result[i] = (int)(scalarY * input[i]);
        }
        return result;
    }

    public skyPositions getPosition() {
        return position;
    }
}


